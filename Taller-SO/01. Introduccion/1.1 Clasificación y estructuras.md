# Clasificación y Estructuras de Sistemas Operativos

## Objetivos de Aprendizaje
- Comprender los diferentes tipos de clasificación de sistemas operativos
- Analizar las estructuras arquitectónicas fundamentales
- Identificar ventajas y desventajas de cada tipo de estructura
- Relacionar la estructura con el rendimiento y funcionalidad del SO

## 1. Clasificación de Sistemas Operativos

### 1.1 Por Número de Usuarios

#### **Monousuario**
Sistemas diseñados para ser utilizados por un solo usuario a la vez.
- **Ejemplos**: MS-DOS, Windows 95/98/ME
- **Características**:
  - Simplicidad en el diseño
  - Menor overhead de gestión
  - Limitaciones en compartición de recursos

#### **Multiusuario**
Sistemas que permiten múltiples usuarios simultáneamente.
- **Ejemplos**: UNIX, Linux, Windows Server
- **Características**:
  - Gestión de permisos y seguridad
  - Aislamiento entre usuarios
  - Compartición controlada de recursos

### 1.2 Por Número de Tareas

#### **Monotarea**
Ejecuta una sola tarea a la vez.
- **Ejemplos**: MS-DOS
- **Características**:
  - Ejecución secuencial
  - Mayor control sobre recursos
  - Limitaciones en productividad

#### **Multitarea**
Permite la ejecución simultánea de múltiples tareas.
- **Tipos**:
  - **Cooperativa**: Las tareas ceden voluntariamente el control
  - **Preemptiva**: El SO controla el tiempo de ejecución

### 1.3 Por Ubicación

#### **Centralizados**
Todos los recursos están en un solo sistema.
- **Características**:
  - Control centralizado
  - Mayor seguridad física
  - Punto único de falla

#### **Distribuidos**
Recursos distribuidos en múltiples sistemas interconectados.
- **Ejemplos**: Cluster computing, sistemas peer-to-peer
- **Características**:
  - Mayor tolerancia a fallos
  - Escalabilidad horizontal
  - Complejidad en la sincronización

## 2. Estructuras de Sistemas Operativos

### 2.1 Estructura Monolítica

#### **Definición**
Todos los componentes del SO se ejecutan en modo kernel como un solo programa.

#### **Características**
- **Ventajas**:
  - Alto rendimiento (pocas llamadas entre módulos)
  - Comunicación directa entre componentes
  - Simplicidad en el diseño inicial

- **Desventajas**:
  - Difícil mantenimiento y depuración
  - Un fallo puede afectar todo el sistema
  - Dificultad para modificaciones

#### **Ejemplos**: Linux tradicional, UNIX System V

### 2.2 Estructura por Capas (Layered)

#### **Definición**
El SO se organiza como una jerarquía de capas, donde cada capa utiliza servicios de la capa inferior.

#### **Modelo Típico**:
```
Capa 5: Programas de Usuario
Capa 4: Interfaz de Usuario
Capa 3: Gestión de I/O
Capa 2: Comunicación Operador-Proceso
Capa 1: Gestión de Memoria y CPU
Capa 0: Hardware
```

#### **Características**:
- **Ventajas**:
  - Modularidad y organización clara
  - Facilita debugging (por capas)
  - Aislamiento entre niveles

- **Desventajas**:
  - Overhead por múltiples capas
  - Dificultad para definir capas apropiadas
  - Rendimiento menor que estructura monolítica

### 2.3 Estructura Microkernel

#### **Definición**
Mantiene solo las funciones esenciales en modo kernel, moviendo otros servicios al espacio de usuario.

#### **Funciones del Microkernel**:
- Gestión básica de procesos
- Comunicación entre procesos (IPC)
- Gestión básica de memoria
- Scheduling básico

#### **Características**:
- **Ventajas**:
  - Mayor confiabilidad (fallos aislados)
  - Facilidad para extensibilidad
  - Portabilidad mejorada
  - Seguridad mejorada

- **Desventajas**:
  - Overhead por comunicación frecuente
  - Complejidad en la implementación
  - Rendimiento potencialmente menor

#### **Ejemplos**: Mach, QNX, Minix

### 2.4 Estructura Híbrida

#### **Definición**
Combina elementos de diferentes estructuras para optimizar rendimiento y funcionalidad.

#### **Características**:
- Microkernel modificado con algunos servicios en modo kernel
- Balance entre rendimiento y modularidad
- Adaptabilidad según necesidades

#### **Ejemplos**: Windows NT/2000/XP/Vista/7/8/10/11, MacOS X

### 2.5 Estructura de Módulos

#### **Definición**
Kernel modular que puede cargar y descargar módulos dinámicamente.

#### **Características**:
- **Ventajas**:
  - Flexibilidad en configuración
  - Uso eficiente de memoria
  - Actualización sin reinicio

- **Desventajas**:
  - Complejidad en gestión de dependencias
  - Posibles problemas de seguridad

#### **Ejemplos**: Linux moderno, Solaris

## 3. Comparación de Estructuras

| Estructura | Rendimiento | Confiabilidad | Mantenibilidad | Complejidad |
|------------|-------------|---------------|----------------|-------------|
| Monolítica | Alto | Baja | Baja | Baja |
| Por Capas | Medio | Media | Media | Media |
| Microkernel | Bajo-Medio | Alta | Alta | Alta |
| Híbrida | Alto | Media-Alta | Media | Alta |
| Modular | Alto | Alta | Alta | Media-Alta |

## 4. Tendencias Actuales

### **Virtualización y Contenedores**
- Separación entre SO host y guest
- Optimización de recursos
- Aislamiento mejorado

### **Sistemas Operativos Distribuidos**
- Computación en la nube
- Sistemas peer-to-peer
- Edge computing

### **SO para IoT y Sistemas Embebidos**
- Real-time operating systems (RTOS)
- Sistemas ultra-ligeros
- Optimización energética

## Referencias

1. Tanenbaum, A. S., & Bos, H. (2014). Modern Operating Systems (4th ed.). Pearson.
2. Silberschatz, A., Galvin, P. B., & Gagne, G. (2018). Operating System Concepts (10th ed.). Wiley.
3. Stallings, W. (2017). Operating Systems: Internals and Design Principles (8th ed.). Pearson.
4. Love, R. (2010). Linux Kernel Development (3rd ed.). Addison-Wesley.
5. Russinovich, M., Solomon, D., & Ionescu, A. (2012). Windows Internals (6th ed.). Microsoft Press.