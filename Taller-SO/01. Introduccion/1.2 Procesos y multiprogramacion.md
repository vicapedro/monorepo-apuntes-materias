# Procesos e Hilos

## Objetivos de Aprendizaje
- Distinguir entre procesos e hilos y sus características
- Comprender los diferentes modelos de threading
- Analizar problemas de concurrencia y sincronización
- Implementar soluciones a problemas clásicos de sincronización
- Evaluar el rendimiento en sistemas multihilo

## 1. Conceptos Fundamentales

### 1.1 Procesos vs Hilos

#### **Proceso**
Un programa en ejecución con su propio espacio de memoria y recursos del sistema.

**Características de los Procesos**:
- Espacio de direcciones independiente
- Recursos propios (archivos abiertos, señales, etc.)
- Comunicación costosa entre procesos (IPC)
- Creación y cambio de contexto costoso
- Mayor protección y aislamiento

#### **Hilo (Thread)**
Una unidad de ejecución dentro de un proceso que comparte recursos con otros hilos del mismo proceso.

**Características de los Hilos**:
- Comparten espacio de memoria con otros hilos del proceso
- Tienen su propia pila y registros
- Creación y cambio de contexto más rápido
- Comunicación sencilla (memoria compartida)
- Menor aislamiento entre hilos

### 1.2 Ventajas de los Hilos

#### **Responsividad**
- La aplicación puede continuar ejecutándose aunque parte esté bloqueada
- Mejor experiencia de usuario en interfaces gráficas

#### **Compartición de Recursos**
- Los hilos comparten memoria y recursos del proceso
- Comunicación eficiente entre hilos

#### **Economía**
- Menor costo de creación y cambio de contexto
- Aprovechamiento de memoria compartida

#### **Escalabilidad**
- Mejor aprovechamiento de sistemas multiprocesador
- Paralelización de tareas

## 2. Estados de los Hilos

### **Estados Básicos**:
1. **Nuevo (New)**: Hilo creado pero no iniciado
2. **Ejecutable (Runnable)**: Listo para ejecutar o ejecutándose
3. **Bloqueado (Blocked)**: Esperando por algún evento
4. **Terminado (Terminated)**: Ejecución completada

### **Transiciones de Estado**:
```
[Nuevo] → [Ejecutable] → [Ejecutándose] → [Terminado]
             ↑              ↓
             ↑         [Bloqueado]
             ↑              ↓
             ←--------------↓
```

## 3. Modelos de Threading

### 3.1 Modelo Muchos-a-Uno (M:1)

#### **Características**:
- Múltiples hilos de usuario mapeados a un solo hilo de kernel
- La biblioteca de hilos maneja el threading en espacio de usuario

#### **Ventajas**:
- Cambio de contexto muy rápido
- Control total sobre scheduling
- Portabilidad

#### **Desventajas**:
- Si un hilo se bloquea, todos los hilos del proceso se bloquean
- No aprovecha multiprocesadores reales

#### **Ejemplos**: Green threads en Java (versiones antiguas), GNU Portable Threads

### 3.2 Modelo Uno-a-Uno (1:1)

#### **Características**:
- Cada hilo de usuario se mapea a un hilo de kernel
- El kernel maneja directamente el threading

#### **Ventajas**:
- Paralelismo real en multiprocesadores
- Si un hilo se bloquea, otros pueden continuar
- Mejor concurrencia

#### **Desventajas**:
- Mayor overhead en creación y cambio de contexto
- Limitado por el número máximo de hilos del kernel

#### **Ejemplos**: Windows threads, hilos POSIX en Linux

### 3.3 Modelo Muchos-a-Muchos (M:N)

#### **Características**:
- M hilos de usuario mapeados a N hilos de kernel
- Combina beneficios de ambos modelos anteriores

#### **Ventajas**:
- Flexibilidad en el mapeo
- Paralelismo real sin limitaciones estrictas
- Mejor utilización de recursos

#### **Desventajas**:
- Complejidad en la implementación
- Overhead en la gestión del mapeo

#### **Ejemplos**: Solaris threads (versiones antiguas), algunos sistemas UNIX

### 3.4 Modelo de Dos Niveles

#### **Características**:
- Combina M:N con 1:1
- Permite hilos bound (ligados directamente al kernel) y unbound

## 4. Bibliotecas de Threading

### 4.1 Pthreads (POSIX threads)

#### **Características**:
- Estándar POSIX para threading
- Disponible en sistemas UNIX/Linux
- API en C

#### **Funciones Principales**:
```c
pthread_create()    // Crear hilo
pthread_join()      // Esperar terminación
pthread_exit()      // Terminar hilo
pthread_mutex_*()   // Operaciones de mutex
pthread_cond_*()    // Variables de condición
```

### 4.2 Windows Threads

#### **Características**:
- API nativa de Windows
- Modelo 1:1

#### **Funciones Principales**:
```c
CreateThread()      // Crear hilo
WaitForSingleObject() // Esperar objeto
ExitThread()        // Terminar hilo
CreateMutex()       // Crear mutex
```

### 4.3 Java Threading

#### **Características**:
- Threading integrado en el lenguaje
- Modelo híbrido dependiendo de la JVM

#### **Clases Principales**:
```java
Thread class        // Clase base para hilos
Runnable interface  // Interfaz para tareas
synchronized        // Palabra clave para sincronización
wait()/notify()     // Métodos de sincronización
```

## 5. Problemas de Concurrencia

### 5.1 Condiciones de Carrera (Race Conditions)

#### **Definición**:
Situación donde el resultado depende del orden específico de ejecución de hilos concurrentes.

#### **Ejemplo**:
```c
// Variable compartida
int counter = 0;

// Hilo 1 y Hilo 2 ejecutan:
counter = counter + 1;  // Operación no atómica
```

### 5.2 Secciones Críticas

#### **Definición**:
Segmento de código que accede a recursos compartidos y debe ejecutarse de forma mutuamente exclusiva.

#### **Requisitos para Solución**:
1. **Exclusión mutua**: Solo un hilo en la sección crítica
2. **Progreso**: La selección del siguiente hilo no puede posponerse indefinidamente
3. **Espera limitada**: Límite en el número de veces que otros hilos pueden entrar

### 5.3 Deadlock

#### **Definición**:
Situación donde dos o más hilos esperan indefinidamente por recursos que otros hilos poseen.

#### **Condiciones Necesarias**:
1. **Exclusión mutua**
2. **Retención y espera**
3. **No apropiación**
4. **Espera circular**

#### **Estrategias de Prevención**:
- Prevenir una de las cuatro condiciones
- Evitar deadlock (algoritmo del banquero)
- Detectar y recuperar
- Ignorar el problema

### 5.4 Starvation

#### **Definición**:
Situación donde un hilo no puede obtener acceso regular a recursos compartidos.

## 6. Mecanismos de Sincronización

### 6.1 Mutex (Mutual Exclusion)

#### **Características**:
- Proporciona exclusión mutua para secciones críticas
- Solo el hilo que adquiere el mutex puede liberarlo

#### **Ejemplo en Pthreads**:
```c
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

pthread_mutex_lock(&mutex);
// Sección crítica
pthread_mutex_unlock(&mutex);
```

### 6.2 Semáforos

#### **Características**:
- Contador que controla acceso a recursos
- Operaciones atómicas: wait() y signal()

#### **Tipos**:
- **Binario**: Equivalente a mutex
- **Contador**: Controla múltiples instancias de recurso

### 6.3 Variables de Condición

#### **Características**:
- Permiten que hilos esperen hasta que se cumpla una condición
- Se usan junto con mutex

#### **Ejemplo**:
```c
pthread_cond_wait(&condition, &mutex);
pthread_cond_signal(&condition);
```

### 6.4 Monitores

#### **Características**:
- Construcción de alto nivel que combina mutex y variables de condición
- Solo un hilo puede estar activo dentro del monitor

## 7. Problemas Clásicos de Sincronización

### 7.1 Problema del Productor-Consumidor

#### **Descripción**:
Productores generan elementos que consumidores procesan, usando un buffer compartido limitado.

#### **Solución con Semáforos**:
```c
semaphore empty = n;    // Espacios vacíos
semaphore full = 0;     // Espacios llenos
semaphore mutex = 1;    // Exclusión mutua
```

### 7.2 Problema de los Lectores-Escritores

#### **Descripción**:
Múltiples lectores pueden acceder simultáneamente, pero escritores requieren acceso exclusivo.

### 7.3 Problema de los Filósofos Comensales

#### **Descripción**:
Cinco filósofos sentados en mesa circular, necesitan dos palillos para comer.

#### **Problemas**:
- Deadlock si todos toman el palillo izquierdo simultáneamente
- Starvation posible

## 8. Consideraciones de Rendimiento

### **Factores que Afectan el Rendimiento**:
1. **Overhead de creación de hilos**
2. **Cambio de contexto**
3. **Sincronización**
4. **False sharing** en cache
5. **Contención por recursos**

### **Optimizaciones**:
- Pool de hilos
- Reducir granularidad de locks
- Usar estructuras de datos lock-free
- Afinidad de procesador

## 9. Hilos en Sistemas Modernos

### **Tendencias Actuales**:
- **Work-stealing**: Balanceamento dinámico de carga
- **Actor model**: Concurrencia basada en mensajes
- **Async/await**: Programación asíncrona
- **Green threads**: Threading ligero en espacio de usuario

## Referencias

1. Tanenbaum, A. S., & Bos, H. (2014). Modern Operating Systems. Pearson.
2. Silberschatz, A., Galvin, P. B., & Gagne, G. (2018). Operating System Concepts. Wiley.
3. Herlihy, M., & Shavit, N. (2012). The Art of Multiprocessor Programming. Morgan Kaufmann.
4. Butenhof, D. R. (1997). Programming with POSIX Threads. Addison-Wesley.
5. Lee, E. A. (2006). The Problem with Threads. Computer, 39(5), 33-42.